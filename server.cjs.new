const express = require('express');
const { createServer } = require('http');
const { Server } = require('socket.io');
const path = require('path');
const { getRandomForfeit } = require('./server_data/forfeits.cjs');
const { allQuestions } = require('./server_data/questions.cjs');

const app = express();

// Add CORS middleware for all Express routes
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  next();
});

const server = createServer(app);
const io = new Server(server, {
  cors: {
    // Allow any origin during development
    origin: function(origin, callback) {
      // Allow all origins for development
      callback(null, true);
    },
    methods: ["GET", "POST", "OPTIONS"],
    credentials: true,
    allowedHeaders: ["Content-Type", "Authorization"]
  },
  connectionStateRecovery: {
    maxDisconnectionDuration: 2 * 60 * 1000,
    skipMiddlewares: true,
  },
  transports: ['polling', 'websocket'],
  allowUpgrades: true,
  pingTimeout: 30000,
  pingInterval: 25000
});

// Game constants
const MAX_PLAYERS = 8;
const STARTING_LIVES = 3;
const POINTS_TO_WIN = 10;

// Game state management
const rooms = new Map();
const questionTimeouts = new Map(); // roomCode -> NodeJS.Timeout

// Utility functions
const generateRoomCode = () => {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
};

const createPlayer = (name, isHost = false) => {
  return {
    id: Math.random().toString(36).substring(2, 9),
    name,
    color: '',
    avatar: '',
    score: 0,
    lives: STARTING_LIVES,
    isHost,
    isEliminated: false,
    categoryScores: {}
  };
};

const playerColors = ['#EF5555', '#4B92FF', '#20C991', '#F5AE1B', '#9B6CF6', '#FC59A9'];
const playerAvatars = ['ðŸ¦Š', 'ðŸ»', 'ðŸ±', 'ðŸ¸', 'ðŸ¦', 'ðŸ¼'];

const assignPlayerAppearance = (player, existingPlayers) => {
  const usedColors = existingPlayers.map(p => p.color);
  const usedAvatars = existingPlayers.map(p => p.avatar);
  
  const availableColors = playerColors.filter(color => !usedColors.includes(color));
  const availableAvatars = playerAvatars.filter(avatar => !usedAvatars.includes(avatar));
  
  player.color = availableColors.length > 0 
    ? availableColors[0] 
    : playerColors[Math.floor(Math.random() * playerColors.length)];
    
  player.avatar = availableAvatars.length > 0 
    ? availableAvatars[0] 
    : playerAvatars[Math.floor(Math.random() * playerAvatars.length)];
  
  return player;
};

// Filter questions by category
const getQuestionsByCategory = (category) => {
  return allQuestions.filter(q => q.category === category);
};

// Get a random question from a specific category
const getRandomQuestionFromCategory = (category, usedQuestionIds = []) => {
  const categoryQuestions = getQuestionsByCategory(category);
  const availableQuestions = categoryQuestions.filter(q => !usedQuestionIds.includes(q.id));
  
  if (availableQuestions.length === 0) {
    // If all questions used, pick any from the category
    return categoryQuestions[Math.floor(Math.random() * categoryQuestions.length)];
  }
  
  return availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
};

// Get all available categories
const getAllCategories = () => {
  const categories = new Set();
  allQuestions.forEach(q => categories.add(q.category));
  return Array.from(categories);
};

// Find the next active player (not eliminated)
const findNextActivePlayerIndex = (room) => {
  let nextIndex = (room.gameState.currentPlayerIndex + 1) % room.gameState.players.length;
  let loopCount = 0;
  
  while (loopCount < room.gameState.players.length) {
    const nextPlayer = room.gameState.players[nextIndex];
    if (!nextPlayer.isEliminated) {
      return nextIndex;
    }
    nextIndex = (nextIndex + 1) % room.gameState.players.length;
    loopCount++;
  }
  
  // If we couldn't find any active player, game should be over
  return -1;
};

// Move to next player turn
const nextTurn = (room, roomCode) => {
  const nextPlayerIndex = findNextActivePlayerIndex(room);
  
  if (nextPlayerIndex === -1) {
    // No active players found, this shouldn't happen but handle it
    endGame(room, roomCode);
    return;
  }
  
  room.gameState.currentPlayerIndex = nextPlayerIndex;
  room.gameState.round++;
  room.gameState.selectedCategory = null;
  room.gameState.gamePhase = 'category_selection';
  
  io.to(roomCode).emit('next-turn', { gameState: room.gameState });
};

// Check if we have a winner or if game should continue
const checkGameStatus = (room, roomCode) => {
  // Count active players
  const activePlayers = room.gameState.players.filter(p => !p.isEliminated);
  
  // If only one active player remains, they win
  if (activePlayers.length === 1) {
    endGame(room, roomCode, activePlayers[0]);
    return true;
  }
  
  // Check if any player has reached the win condition (10+ points)
  const winner = room.gameState.players.find(p => !p.isEliminated && p.score >= POINTS_TO_WIN);
  if (winner) {
    endGame(room, roomCode, winner);
    return true;
  }
  
  return false;
};

// End the game
const endGame = (room, roomCode, winner = null) => {
  room.gameState.gamePhase = 'finished';
  room.gameState.winner = winner;
  
  io.to(roomCode).emit('game-finished', { gameState: room.gameState });
};

// Socket event handlers
io.on('connection', (socket) => {
  console.log('User connected:', socket.id, 'from address:', socket.handshake.address);

  socket.on('create-room', (hostName, callback) => {
    try {
      console.log('Received create-room event from socket:', socket.id);
      console.log('Attempting to create room with host:', hostName);
      const roomCode = generateRoomCode();
      const host = createPlayer(hostName, true);
      // Store the persistent ID with the player
      host.persistentId = socket.handshake.auth.persistentId || null;
      const assignedHost = assignPlayerAppearance(host, []);
      
      const gameState = {
        id: roomCode,
        players: [assignedHost],
        currentPlayerIndex: 0,
        currentQuestion: null,
        selectedCategory: null,
        gamePhase: 'waiting',
        winner: null,
        round: 1,
        currentForfeit: null,
        charadeSolution: null,
        charadeSolved: false
      };

      const room = {
        id: roomCode,
        gameState,
        usedQuestionIds: []
      };

      rooms.set(roomCode, room);
      socket.join(roomCode);
      
      console.log('Room created successfully:', roomCode);
      if (typeof callback === 'function') {
        callback({ success: true, roomCode, gameState });
      }
    } catch (error) {
      console.error('Error creating room:', error);
      if (typeof callback === 'function') {
        callback({ success: false, error: 'Failed to create room: ' + error.message });
      }
    }
  });

  socket.on('join-room', (roomCode, playerName, callback) => {
    console.log('Attempting to join room:', roomCode, 'with player:', playerName);
    const room = rooms.get(roomCode);
    
    if (!room) {
      console.log('Room not found:', roomCode);
      callback({ success: false, error: 'Room not found' });
      return;
    }

    if (room.gameState.players.length >= MAX_PLAYERS) {
      callback({ success: false, error: 'Room is full' });
      return;
    }

    if (room.gameState.gamePhase !== 'waiting') {
      callback({ success: false, error: 'Game already started' });
      return;
    }

    const newPlayer = createPlayer(playerName);
    const assignedPlayer = assignPlayerAppearance(newPlayer, room.gameState.players);
    
    room.gameState.players.push(assignedPlayer);
    socket.join(roomCode);
    
    io.to(roomCode).emit('player-joined', { gameState: room.gameState, player: assignedPlayer });
    callback({ success: true, gameState: room.gameState, playerId: assignedPlayer.id, roomCode });
  });

  socket.on('start-game', (roomCode) => {
    const room = rooms.get(roomCode);
    if (!room || room.gameState.players.length < 2) return;

    room.gameState.gamePhase = 'category_selection';
    io.to(roomCode).emit('game-started', { gameState: room.gameState });
  });

  socket.on('select-category', (roomCode, playerId, category) => {
    const room = rooms.get(roomCode);
    if (!room) return;

    const currentPlayer = room.gameState.players[room.gameState.currentPlayerIndex];
    if (currentPlayer.id !== playerId || room.gameState.gamePhase !== 'category_selection') return;

    // Get a question from selected category
    const question = getRandomQuestionFromCategory(category, room.usedQuestionIds);
    room.usedQuestionIds.push(question.id);
    
    room.gameState.selectedCategory = category;
    room.gameState.currentQuestion = question;
    room.gameState.gamePhase = 'question';
    
    io.to(roomCode).emit('category-selected', {
      category,
      question,
      gameState: room.gameState,
      playerId
    });

    // Set timeout for question (30 seconds)
    const existing = questionTimeouts.get(roomCode);
    if (existing) clearTimeout(existing);

    const timeoutMs = 30000;
    const handle = setTimeout(() => {
      // If player hasn't answered, treat as incorrect
      if (room.gameState.gamePhase === 'question' && room.gameState.currentQuestion) {
        handleIncorrectAnswer(room, roomCode, currentPlayer);
      }
    }, timeoutMs);
    
    questionTimeouts.set(roomCode, handle);
  });

  socket.on('submit-answer', (roomCode, playerId, answerIndex) => {
    const room = rooms.get(roomCode);
    if (!room || !room.gameState.currentQuestion || room.gameState.gamePhase !== 'question') return;

    const currentPlayer = room.gameState.players[room.gameState.currentPlayerIndex];
    if (currentPlayer.id !== playerId) return;

    // Clear question timeout
    const existing = questionTimeouts.get(roomCode);
    if (existing) clearTimeout(existing);
    questionTimeouts.delete(roomCode);

    const isCorrect = answerIndex === room.gameState.currentQuestion.correctAnswer;
    
    if (isCorrect) {
      // Handle correct answer
      handleCorrectAnswer(room, roomCode, currentPlayer, room.gameState.selectedCategory);
    } else {
      // Handle incorrect answer
      handleIncorrectAnswer(room, roomCode, currentPlayer);
    }
  });
  
  socket.on('start-charade', (roomCode, playerId) => {
    const room = rooms.get(roomCode);
    if (!room || room.gameState.gamePhase !== 'forfeit') return;

    const currentPlayer = room.gameState.players[room.gameState.currentPlayerIndex];
    if (currentPlayer.id !== playerId) return;

    room.gameState.charadeSolved = false;
    room.gameState.charadeSolution = room.gameState.currentForfeit.wordToAct;
    room.gameState.gamePhase = 'charade_guessing';
    
    io.to(roomCode).emit('charade-started', { gameState: room.gameState });

    // Set timeout for charade (60 seconds)
    const timeoutMs = 60000;
    const handle = setTimeout(() => {
      if (room.gameState.gamePhase === 'charade_guessing' && !room.gameState.charadeSolved) {
        // Time's up, player loses a life
        handleFailedCharade(room, roomCode, currentPlayer);
      }
    }, timeoutMs);
    
    questionTimeouts.set(roomCode, handle);
  });
  
  socket.on('guess-charade', (roomCode, playerId, guess) => {
    const room = rooms.get(roomCode);
    if (!room || room.gameState.gamePhase !== 'charade_guessing') return;

    const currentPlayer = room.gameState.players[room.gameState.currentPlayerIndex];
    if (currentPlayer.id === playerId) return; // Current player can't guess their own charade
    
    const solution = room.gameState.charadeSolution.toLowerCase();
    const normalizedGuess = guess.toLowerCase();
    
    // Check if the guess is correct (allow partial matches)
    if (solution.includes(normalizedGuess) || normalizedGuess.includes(solution)) {
      // Correct guess!
      handleCorrectCharadeGuess(room, roomCode, currentPlayer, playerId);
    } else {
      // Wrong guess, notify everyone
      io.to(roomCode).emit('incorrect-charade-guess', {
        guessingPlayerId: playerId,
        guess
      });
    }
  });

  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
    // Could handle player disconnection here
  });
});

// Helper functions for game logic
function handleCorrectAnswer(room, roomCode, player, category) {
  // Award a point for the category
  if (!player.categoryScores[category]) {
    player.categoryScores[category] = 0;
  }
  player.categoryScores[category]++;
  player.score++;
  
  // Send result to clients
  io.to(roomCode).emit('answer-submitted', {
    playerId: player.id,
    isCorrect: true,
    points: 1,
    gameState: room.gameState
  });
  
  // Check if game should end
  if (checkGameStatus(room, roomCode)) {
    return;
  }
  
  // Move to next player's turn
  setTimeout(() => nextTurn(room, roomCode), 3000);
}

function handleIncorrectAnswer(room, roomCode, player) {
  // Get a forfeit for the player
  const forfeit = getRandomForfeit();
  room.gameState.currentForfeit = forfeit;
  room.gameState.gamePhase = 'forfeit';
  
  // Send result to clients
  io.to(roomCode).emit('answer-submitted', {
    playerId: player.id,
    isCorrect: false,
    forfeit,
    gameState: room.gameState
  });
}

function handleCorrectCharadeGuess(room, roomCode, actingPlayer, guessingPlayerId) {
  // Clear any timeout
  const existing = questionTimeouts.get(roomCode);
  if (existing) clearTimeout(existing);
  questionTimeouts.delete(roomCode);
  
  // Get the player who guessed correctly
  const guessingPlayer = room.gameState.players.find(p => p.id === guessingPlayerId);
  
  // Acting player loses a life
  actingPlayer.lives--;
  
  // Check if player is eliminated
  if (actingPlayer.lives <= 0) {
    actingPlayer.isEliminated = true;
  }
  
  // Mark charade as solved
  room.gameState.charadeSolved = true;
  
  // Send result to clients
  io.to(roomCode).emit('charade-solved', {
    actingPlayerId: actingPlayer.id,
    guessingPlayerId,
    solution: room.gameState.charadeSolution,
    gameState: room.gameState
  });
  
  // Check if game should end
  if (checkGameStatus(room, roomCode)) {
    return;
  }
  
  // Move to next player's turn
  setTimeout(() => nextTurn(room, roomCode), 3000);
}

function handleFailedCharade(room, roomCode, player) {
  // Mark charade as solved (failed)
  room.gameState.charadeSolved = true;
  
  // Send result to clients
  io.to(roomCode).emit('charade-failed', {
    playerId: player.id,
    solution: room.gameState.charadeSolution,
    gameState: room.gameState
  });
  
  // Move to next player's turn
  setTimeout(() => nextTurn(room, roomCode), 3000);
}

// Serve static files in production
app.use(express.static('dist'));

// Handle client-side routing
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'dist', 'index.html'));
});

const PORT = process.env.PORT || 3001;
server.listen(PORT, '0.0.0.0', () => {
  console.log(`Game server running on port ${PORT}`);
});
